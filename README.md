## Table of Contents

* [Docker](#docker)
* [Orchestration](#orchestration)
* [Images](#images)
* [Containers](#containers)
* [Volumes](#volumes)
* [Dockerfile](#dockerfile)
* [Docker-Compose](#docker-compose)
* [Docker CLI](Docker-CLI.md)
* [Sample Project](Sample-Project.md)
* [Miscellaneous](Miscellaneous.md)

Docker(docker) written in **GO** language : Docker compose(docker compose) written in **PYTHON**

## Docker
Docker is an open source platform that enables developers to build, deploy, run, update and manage containers—standardized, executable components that combine application source code with the operating system (OS) libraries and dependencies required to run that code in any environment. For more details
[visit here](https://docs.docker.com/get-started/overview/).

### Docker technology ### 
Docker technology consists of the runtime, engine and orchestrator

* **Runtime:** Responsible for starting and stopping containers.

* **Daemon/Engine:** Expose the Docker remote API, manage images, volumes, networks etc.

* **Orchestrator:** Manging clusters (Swarns) of nodes running docker.

![Docker technology](/images/docker-technology.png)

### Docker architecture ###

Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. Another Docker client is Docker Compose, that lets you work with applications consisting of a set of containers.

![Docker architecture](/images/docker-architecture.png)

**docker pull:** Docker pull with verify if the image is already downloaded locally, if not it will download it from DockerHub.
*Ex: docker pull drupal*

**docker build:** Docker build will build the current Dockerfile and will create locally an image for our application.
*Ex: docker build .*

**docker run:** Docker run will take the image and run the container.
*Ex: docker run nginx*

**docker push:** Docker push will upload the image/extension/plugin to DockerHub.
*Ex: docker push <application image>*


## Orchestration

Container orchestration is the automation of much of the operational effort required to run containerized workloads and services. This includes a wide range of things software teams need to manage a container’s lifecycle, including provisioning, deployment, scaling (up and down), networking, load balancing and more.

The things that container orchestration will do:

1. **Deployment**
2. **Scaling:** schedule containers to the right worker node for the best resources utilization
3. **Networking:** create load balancers for external and internal services communication
4. **Operations and Insight:** automatically bring up instances of a services in failure; provide integration points for service mesh and logging

**References**

* [Official docker orchestration](https://docs.docker.com/get-started/orchestration/)

* [Other reference](https://avinetworks.com/glossary/container-orchestration/)

* [Quick reference](https://www.redhat.com/en/topics/containers/what-is-container-orchestration)

* [Why do we need container orchestration?](https://www.vmware.com/topics/glossary/content/container-orchestration.html)

## Images

An image is a read-only template with instructions for creating a Docker container.

## Containers
Containers are executable units of software in which application code is packaged, along with its libraries and dependencies, in common ways so that it can be run anywhere, whether it be on desktop, traditional IT, or the cloud.

[Your basic isolated Docker process](http://etherealmind.com/basics-docker-containers-hypervisors-coreos/). Containers are to Virtual Machines as threads are to processes.

A container is a runable instance of an image. Can create, start, stop, move or delete a container using the Docker API or CLI.

![Container](/images/container.png)

## Volumes
Two main categories of data: Persistent and non-persistent

* **Non-persistent:** Data gets written to the top layer and gets deleted with the container.

* **Persistent:** Need to keep even after container deletion.

Volumes are used to persist data

Docker volumes are a widely used and useful tool for ensuring data persistence while working in containers. Docker volumes are file systems mounted on Docker containers to preserve data generated by the running container.

**References**

* [Official docker volumes](https://docs.docker.com/storage/volumes/)

* [Other reference](https://earthly.dev/blog/docker-volumes/)

* [Quick reference](https://phoenixnap.com/kb/what-is-docker)

## Dockerfile

A Dockerfile is the starting point for creating a container image. It describes an application and tells Docker how to build it into an image. For more details [visit here](https://docs.docker.com/engine/reference/builder/)

**WHY:** To customize our container

**Dockerfile** ==> *docker build* ==> **Docker image** ==> *docker run* ==> **Docker Container**

### Instructions / Commands

* [.dockerignore](https://docs.docker.com/engine/reference/builder/#dockerignore-file)
* [FROM](https://docs.docker.com/engine/reference/builder/#from) Sets the Base Image for subsequent instructions.
* [MAINTAINER (deprecated - use LABEL instead)](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated) Set the Author field of the generated images.
* [RUN](https://docs.docker.com/engine/reference/builder/#run) execute any commands in a new layer on top of the current image and commit the results.
* [CMD](https://docs.docker.com/engine/reference/builder/#cmd) provide defaults for an executing container.
* [EXPOSE](https://docs.docker.com/engine/reference/builder/#expose) informs Docker that the container listens on the specified network ports at runtime.  NOTE: does not actually make ports accessible.
* [ENV](https://docs.docker.com/engine/reference/builder/#env) sets environment variable.
* [ADD](https://docs.docker.com/engine/reference/builder/#add) copies new files, directories or remote file to container.  Invalidates caches. Avoid `ADD` and use `COPY` instead.
* [COPY](https://docs.docker.com/engine/reference/builder/#copy) copies new files or directories to container.  By default this copies as root regardless of the USER/WORKDIR settings.  Use `--chown=<user>:<group>` to give ownership to another user/group.  (Same for `ADD`.)
* [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint) configures a container that will run as an executable.
* [VOLUME](https://docs.docker.com/engine/reference/builder/#volume) creates a mount point for externally mounted volumes or other containers.
* [USER](https://docs.docker.com/engine/reference/builder/#user) sets the user name for following RUN / CMD / ENTRYPOINT commands.
* [WORKDIR](https://docs.docker.com/engine/reference/builder/#workdir) sets the working directory.
* [ARG](https://docs.docker.com/engine/reference/builder/#arg) defines a build-time variable.
* [ONBUILD](https://docs.docker.com/engine/reference/builder/#onbuild) adds a trigger instruction when the image is used as the base for another build.
* [STOPSIGNAL](https://docs.docker.com/engine/reference/builder/#stopsignal) sets the system call signal that will be sent to the container to exit.
* [LABEL](https://docs.docker.com/config/labels-custom-metadata/) apply key/value metadata to your images, containers, or daemons.
* [SHELL](https://docs.docker.com/engine/reference/builder/#shell) override default shell is used by docker to run commands.
* [HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck) tells docker how to test a container to check that it is still working.

**Example**
```
# Base image
FROM ubuntu:22.04
RUN echo "It is working fine!!"

ENV TZ=Asia/Kolkata DEBIAN_FRONTEND=noninteractive

RUN apt-get update && apt-get install tzdata

# Work directory
WORKDIR /var/www/html

# Install Apache
RUN apt-get -y install apache2 
RUN apt-get -y install apache2-utils 
RUN apt-get clean 
EXPOSE 80

# Enable rewrite module
RUN a2enmod rewrite

# Install PHP
RUN apt-get -y install --no-install-recommends php8.1
RUN apt-get -y install php8.1-common php8.1-mysql php8.1-zip php8.1-gd php8.1-mbstring php8.1-curl

# Install composer
RUN php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" && \
	php composer-setup.php && \
	mv composer.phar /usr/local/bin/composer && \
	php -r "unlink('composer-setup.php');"
ENV PATH="~/.composer/vendor/bin:${PATH}"

# Remove apache default index html file
RUN rm -rf index.html

# Define path variable
ARG SITE_PATH=/var/www/html
ENV PATH=$SITE_PATH

# This is resolve 404 isseue
RUN echo "\n<Directory /var/www/>" >> /etc/apache2/apache2.conf
RUN echo "\t Options Indexes FollowSymLinks" >> /etc/apache2/apache2.conf
RUN echo "\t AllowOverride All" >> /etc/apache2/apache2.conf
RUN echo "\t Require all granted" >> /etc/apache2/apache2.conf
RUN echo "</Directory>" >> /etc/apache2/apache2.conf

RUN echo "Done, please browse to http://127.0.0.1:8000/web to check!"
RUN service apache2 restart


#Install drush
RUN composer global require drush/drush

CMD ["/usr/sbin/apachectl", "-D", "FOREGROUND"]
```

## Docker Compose

Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose [visit here](https://docs.docker.com/compose/compose-file/).

**Example**
```
version: '3.1'

services:

# Pull image of mariadb
  drupal10_db: # this is host of database
    image: mariadb:10.5.9
    container_name: mariadb
    ports:
      - 3308:3307
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MYSQL_DATABASE=drupal10
      - MYSQL_USER=drupal10
      - MYSQL_PASSWORD=drupal10

# Pull image of drupal from dockerfile
  drupal:
    container_name: "${COMPOSE_PROJECT_NAME}"
    depends_on:
      - drupal10_db
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:80"
    volumes:
      - d_modules:/var/www/html/web/modules
      - d_themes:/var/www/html/web/themes
      - d_profiles:/var/www/html/web/profiles
      - d_sites:/var/www/html/web/sites
    links:
      - drupal10_db:mariadb
    restart: always

# Pull image of phpmyadmin
  phpmyadmin:
    image: phpmyadmin:5.2.0
    container_name: phpmyadmin
    ports:
      - 9000:80
    environment:
      - PMA_ARBITRARY=1
    restart: always

volumes:
  d_modules:
  d_themes:
  d_profiles:
  d_sites:
```

### Play with Docker

Play with Docker (PWD) provides a free-to-use fully functional Docker playground that lasts for 4 hours. For playing with docker [click here](https://labs.play-with-docker.com/)
	
##### [Next Page >>](Docker-CLI.md)

